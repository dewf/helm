module Widget;

import Common;
import Signal;
import Layout;
import Painter;

int WIDGET_SIZE_MAX;   // pass-through of QWIDGETSIZE_MAX

opaque Handle {
    void setEnabled(bool state);
    void setMaximumWidth(int maxWidth);
    void setMaximumHeight(int maxHeight);
    Rect getRect();
    void resize(int width, int height);

    void show();
    void hide();
    void setVisible(bool state);

    void setWindowTitle(string title);

    void setLayout(Layout.Handle layout);
    Layout.Handle getLayout();

    // would be better to have signal properties that could be connected in the traditional way (eg .WindowTitleChanged.connect(...))
    // but this is a simple demo ...
    void onWindowTitleChanged(Signal.StringDelegate func);
}

Handle create();

// SUBCLASSING ===========================================================

flags MethodMask {
    PaintEvent = 1 << 0,
    MousePressEvent = 1 << 1
}

struct MouseEvent {
    Point pos;
}

// sadly client will have to implement all of these, BUT empty methods / returning default values will be OK
// because only those included in the "method mask" will actually be invoked
interface MethodDelegate {
    void paintEvent(Painter.Handle painter, Rect rect);
    void mousePressEvent(MouseEvent mouseEvent);
}

// allows us to inject the Widget instance into the method delegate
// not strictly necessary but leads to cleaner client code -- can use a primary constructor, don't have to make the internal widget nullable / assigned later, etc.
delegate MethodDelegate CreateDelegateFunc(Handle widget);

Handle createSubclassed(CreateDelegateFunc createFunc, MethodMask methodMask);
