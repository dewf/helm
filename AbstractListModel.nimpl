module AbstractListModel;

import AbstractItemModel;
import Enums;
import Variant;
import ModelIndex;

opaque Handle extends AbstractItemModel.Handle {
    Interior getInteriorHandle();
}

opaque Interior extends Handle { // this opaque allows the method delegate to call internal methods as if it's a direct subclass
    // signal emission
    void emitDataChanged(ModelIndex.Deferred topLeft, ModelIndex.Deferred bottomRight, Array<ItemDataRole> roles);
    void emitHeaderDataChanged(Orientation orientation, int first, int last);

    // for access to protected stuff from MethodDelegate
    void beginInsertRows(ModelIndex.Deferred parent, int first, int last);
    void endInsertRows();

    void beginRemoveRows(ModelIndex.Deferred parent, int first, int last);
    void endRemoveRows();

    void beginResetModel();
    void endResetModel();
}

flags ItemFlags {
    NoItemFlags = 0,
    ItemIsSelectable = 1,
    ItemIsEditable = 2,
    ItemIsDragEnabled = 4,
    ItemIsDropEnabled = 8,
    ItemIsUserCheckable = 16,
    ItemIsEnabled = 32,
    ItemIsAutoTristate = 64,
    ItemNeverHasChildren = 128,
    ItemIsUserTristate = 256
}

flags MethodMask {
    // required, so not in mask:
    // RowCount
    // Data

    // optional:
    HeaderData = 1,
    Flags = 1 << 1,
    SetData = 1 << 2
}

interface MethodDelegate {
    int rowCount(ModelIndex.Handle parent);
    Variant.Deferred data(ModelIndex.Handle index, ItemDataRole role);
    
    // "optional" (we still have to implement, but only active if mask flag is set)
    Variant.Deferred headerData(int section, Orientation orientation, ItemDataRole role);
    ItemFlags getFlags(ModelIndex.Handle index, ItemFlags baseFlags);
    bool setData(ModelIndex.Handle index, Variant.Handle value, ItemDataRole role);
}

Handle createSubclassed(MethodDelegate methodDelegate, MethodMask mask);
